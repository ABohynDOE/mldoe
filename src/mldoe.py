# -*- coding: utf-8 -*-
"""
mldoe
========
The core module of this package
"""

from itertools import chain
from tqdm import tqdm

# Package import
import numpy as np
import oapackage as oa
import concurrent.futures

# Relative imports
from MPP import Kt
from matrix import bmat

# Classes

class __Design:
    pass


class TLdes(__Design):
    """
    TODO: add doc
    """

    def __init__(self, n_runs, cols):
        # Value check
        if n_runs <= 0 or (n_runs & n_runs - 1) != 0:
            raise ValueError('Number of runs must be a positive integer')
        if any([not (c in range(1, n_runs)) for c in cols]):
            raise ValueError(
                'Column numbers should be integers between 1 and n_runs')

        # Set self values
        self.n_runs = n_runs
        self.r = int(np.log2(self.n_runs))
        self.cols = cols
        self.n_fac = len(self.cols)
        self.bf = [2 ** i for i in range(self.r)]
        self.af = [c for c in self.cols if c not in self.bf]
        if not self.af:
            self.lastcol = 0
        else:
            self.lastcol = self.cols[-1]
        # Check if mixed
        self.mixed = False

    def __repr__(self):
        return f'TLdes({self.n_runs},{self.cols})'

    @property
    def array(self) -> np.array:
        """
        Design matrix

        :return: Design matrix
        """
        b_mat = bmat(self.r)
        return b_mat[:, [i - 1 for i in self.cols]]

    @property
    def wlp(self) -> tuple:
        """
        Word length pattern

        :return: word-length pattern as a vector, starting at length 3.
        :rtype: tuple
        """
        return oa.array_link(self.array).GWLP()[3:]

    @property
    def resolution(self):
        first_nz = next((idx for idx, wlp_val in enumerate(self.wlp) if wlp_val), None)
        if first_nz is None:
            return len(self.wlp) + 3
        else:
            return first_nz + 3

    @property
    def MPP(self):
        return Kt(self.array).ID()

    # TODO: implement yield for generators
    def st_gen(self, res: int = 3) -> list:
        """
        Sort the eligible generators for an added factor.

        :param res: Minimal resolution, defaults to 3
        :type res: int, optional
        :return: eligible generators in search-table order
        :rtype: list
        """
        out = list()
        for gen in range(1, self.n_runs):
            if gen in self.bf or gen in self.af:
                continue
            elif gen <= self.lastcol:
                continue
            elif gen_len(gen, self.r) < res - 2:
                continue
            elif any([gen_len(gen ^ c, self.r) < res - 2 for c in self.cols if c < gen]):
                continue
            else:
                out.append(gen)
        return out

    def dop_gen(self, res: int = 3) -> list:
        out = list()
        for gen in range(1, self.n_runs):
            if gen in self.bf or gen in self.af:
                continue
            elif gen_len(gen, self.r) < res - 2:
                continue
            elif any([gen_len(gen ^ c, self.r) < res - 2 for c in self.cols if c < gen]):
                continue
            else:
                out.append(gen)
        return out

    def dop(self) -> list:
        """
        Generates the delete-one-factor projection (DOP) of the design.

        DOPs are generated by sequentially removing column 1 to column n.

        :return: list of the n DOPs
        """
        out = list()
        col: int
        for col in self.cols:
            dop_cols = self.cols.copy()
            dop_cols.remove(col)
            out.append(TLdes(self.n_runs, dop_cols))
        return out


class MLdes(__Design):
    """
    TODO: add docs
    """

    def __init__(self, n_runs, pf_lst, cols):
        # Value check
        if n_runs <= 0 or (n_runs & n_runs - 1) != 0:
            raise ValueError('Number of runs must be a positive integer')
        if any([(c not in range(1, n_runs)) for c in cols]):
            raise ValueError(
                'Column numbers should be integers between 1 and n_runs')
        if not all([triplet[0] ^ triplet[1] == triplet[2] for triplet in pf_lst]):
            raise ValueError(
                'All pseudo-factor triplets must be of the form a,b,ab')
        if any([(c not in range(1, n_runs)) for c in list(chain(*pf_lst))]):
            raise ValueError(
                'Pseudo-factor column numbers should be integers between 1 and n_runs')
        if any([not (c in range(1, n_runs)) for c in cols]):
            raise ValueError(
                'Column numbers should be integers between 1 and n_runs')

        # Set self values
        self.n_runs = n_runs
        self.r = int(np.log2(self.n_runs))
        self.cols = cols
        self.n_fac2 = len(self.cols)
        self.bf = [2 ** i for i in range(self.r)]
        self.pf = pf_lst
        self.__pf_flat = list(chain(*self.pf))
        self.n_fac4 = len(self.__pf_flat)
        self.n_fac = self.n_fac2 + self.n_fac4
        self.af = [c for c in self.cols if c not in self.bf]
        if not self.af:
            self.lastcol = 0
        else:
            self.lastcol = self.cols[-1]
        # Check if mixed
        self.mixed = True

    @property
    def array(self):
        """
        Design matrix

        :return: Design matrix
        :rtype: numpy.array
        """
        b_mat = bmat(self.r)
        mat = np.zeros((self.n_runs, self.n_fac), dtype=np.int8)
        for idx, pf in enumerate(self.pf):
            mat[:, idx] = 2 * b_mat[:, pf[0]] + b_mat[:, pf[1]]
        mat[:, self.n_fac4:] = b_mat[:, [c - 1 for c in self.cols]]
        return mat

    @property
    def wlp(self):
        """
        Word length matrix.
        A matrix where each row represents the type-specific word length pattern.
        For m four-level factors, there can be words of type m at maximum.

        :return: word-length matrix, starting at length 3.
        :rtype: numpy.array
        """
        return oa.array_link(self.array).GWLP()[3:]


# Helper functions


def gen_len(gen, r):
    """
    Compute the length of a given generator

    :param gen: generator as column number
    :type gen: int
    :param r: number of basic factors
    :type r: int
    :return: length of the generators
    :rtype: int
    """
    # # Alternative
    # return sum(map(int,"{0:b}".format(gen)))
    return sum([(gen & 2 ** i) == 2 ** i for i in range(r)])


# Extension functions

def st_select(des, res: int) -> list:
    """
    Use the search-table method to generate candidate designs from a parent design.

    Search-table (ST) method only entertains a candidate design if its last column has a lower search-table index than
    the last column of its parent.

    :param des: parent design
    :type des: TLdes class or MLdes class
    :param res: minimal resolution for candidates
    :type res: int
    :return: list of candidate designs
    :rtype: list
    """
    out = list()
    # TODO: try with blist
    if des.mixed:
        for col in des.st_gen(res=res):
            out.append(MLdes(des.n_runs, des.pf, des.cols + [col]))
    else:
        for col in des.st_gen(res=res):
            out.append(TLdes(des.n_runs, des.cols + [col]))
    return out


def dop_select(des, res: int) -> list:
    """
    Use the delete-one-factor projection (DOP) method to generate candidate designs from a parent design.

    DOP method only entertains a candidate if its parent design has minimum aberration (MA) among all its DOP.

    :param des: parent design
    :param res: minimal resolution for candidates
    :return: list of candidate designs
    """
    if des.mixed:
        return list()
    else:
        dop_candi_lst = list()
        for col in des.dop_gen(res=res):
            temp_candidate = TLdes(des.n_runs, des.cols + [col])
            dop_wlp_lst = [d.wlp for d in temp_candidate.dop()]
            if any([wlp < dop_wlp_lst[-1] for wlp in dop_wlp_lst[:-1]]):
                continue
            else:
                dop_candi_lst.append(temp_candidate)
    return dop_candi_lst


# Partitioning
def partition(candidate_lst: list, res: int) -> dict:
    """
    Partition a list of candidate designs according the MPP.
    All designs with a resolution lower than res are discarded.

    :param candidate_lst: list of candidate design (as objects from the design class)
    :param res: minimal resolution
    :return: dict of the different partitions and the designs they contain
    """
    mpp_dict = dict()
    for d in candidate_lst:
        # Discard low resolution
        if d.resolution < res:
            continue
        else:
            if d.MPP in mpp_dict.keys():
                mpp_dict[d.MPP].append(d)
            else:
                mpp_dict[d.MPP] = [d]
    return mpp_dict


def multi_processes_partition_iso_reduction(mpp_dict: dict, verbose: int = 1) -> list:
    # max_thread = max([100, len(mpp_dict)])
    # with concurrent.futures.ThreadPoolExecutor(max_workers=max_thread) as executor:
    #     futures = []
    #     for key in mpp_dict.keys():
    #         futures.append(executor.submit(select_iso_classes, mpp_dict[key]))
    # return [future.result() for future in concurrent.futures.as_completed(futures)]
    with concurrent.futures.ProcessPoolExecutor(max_workers=8) as executor:
        futures = []
        idx = 1
        if verbose:
            enumerator = tqdm(mpp_dict.keys())
        else:
            enumerator = mpp_dict.keys()
        for key in enumerator:
            idx += 1
            futures.append(executor.submit(select_iso_classes, mpp_dict[key]))
    return [future.result() for future in concurrent.futures.as_completed(futures)]


def partition_iso_reduction(mpp_partition: dict, verbose: int = 1) -> list:
    """
    Reduces a partition of candidate designs (with the same MPP) into a single representative per isomorphism class.
    Singleton classes are automatically considered as representatives.

    :param mpp_partition: single MPP partition
    :param verbose: verbosity level. If 1 displays global progress bar. If 2 displays progress bar over the partitions.
    :return: list of the representatives in the partition
    """
    if len(mpp_partition) == 1:
        return list(mpp_partition)
    else:
        return select_iso_classes(list(mpp_partition), verbose=verbose)


def select_iso_classes(des_lst: list, verbose: int = 2) -> list:
    """
    Reduce all designs in a list to their graph form and selects the non-isomorphic designs using the NAUTY graph
    isomorphism algorithm (Mc Kay et al. 2014)

    :param des_lst: list of candidate designs
    :param verbose: verbosity level. If > 1 displays progress bar
    :return: list of the non-isomorphic designs in the input set
    """
    mm = []
    if verbose > 1:
        enumerator = tqdm(iterable=enumerate(des_lst), desc='Arrays processed: ', total=len(des_lst))
    else:
        enumerator = enumerate(des_lst)
    for idx, des in enumerator:
        al = oa.array_link(des.array)  # Convert to OApackage format
        tt = oa.reduceOAnauty(al)  # Convert to OA graph
        alx = tt.apply(al)  # Apply graph changes
        mm.append(np.array(alx))
    nn = len(mm)
    qq = np.array([None] * nn, dtype=object)
    for ii, ar in enumerate(mm):
        qq[ii] = ar.flatten()  # Flatten the arrays
    _, indices = np.unique(np.vstack(qq), axis=0, return_inverse=True)  # Find unique vectors
    _, zz = np.unique(indices, return_index=True)  # Select one rep. per class
    zz.sort()
    return [des_lst[x] for x in list(zz)]


if __name__ == "__main__":
    import time

    # N128n8 catalog
    catN128n8 = [TLdes(128, [2 ** i for i in range(7)] + [col]) for col in [7, 15, 31, 63, 127]]
    cat = catN128n8
    # Iterate for n=9 and n=10
    for n in [9, 10, 11]:
        # Find ST candidates
        full_st_cand = list(chain(*[st_select(des, res=4) for des in cat]))
        cand_part_dict = partition(full_st_cand, res=4)
        # Find representatives
        # Normal method
        norm_start = time.time()
        # rep_lst_norm = list(chain(*[partition_iso_reduction(cand_part_dict[key]) for key in cand_part_dict.keys()]))
        norm_end = time.time()
        # Threaded method
        thread_start = time.time()
        rep_lst_thread = list(chain(*multi_processes_partition_iso_reduction(cand_part_dict, verbose=1)))
        thread_end = time.time()
        cat = rep_lst_thread
        print(f'128 runs - {n} factors:')
        print(f'Normal : {norm_end - norm_start} s\nThreaded : {thread_end - thread_start} s')
        print(f'Number of candidates: {len(full_st_cand)}\nNumber of representatives: {len(rep_lst_thread)}')
